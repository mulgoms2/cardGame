<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        user-select: none;
        background-color: rgba(204, 196, 196, 0.32);
      }

      img {
        width: 80px;
        height: 120px;
        margin: 5px;
        transition: 0.35s;
      }

      img.clickAble {
        transition: 0.35s;
        cursor: pointer;
      }

      img.clickAble:hover {
        transition: 0.35s;
        box-shadow: 0px 0px 10px green;
      }

      img.flip {
        transform: scaleX(-1);
        transition: 0.35s;
      }

      #board {
        display: grid;
        grid-template-columns: repeat(13, 1fr);
      }
    </style>
  </head>
  <body>
    <div id="buttonBox">
      <button id="hintBtn" onclick="hint()">힌트</button>
      <!-- <button id="hideBtn" onclick="hideAll()">숨기기</button> -->
      <button id="restartBtn" onclick="reStart()">재시작</button><br />
    </div>
    <div id="scoreBoard">
      <p style="font-size: 20px" id="score">score : 0</p>
    </div>
    <div id="board">
      <!-- 52장의 카드를 보여준다. -->
    </div>

    <script>
      const board = document.getElementById("board");
      const CARDS_NUM = 52;
      const SHOW_ALL_TIME = 4000;
      const SHOW_HINT_TIME = 2000;

      // 기존의 카드 초기화를 위한 배열
      let randNumArr = [];

      // 카드의 짝을 확인하기 위한 배열
      let twoCards = [];
      // let 정답카운트 = 0;

      // 정답배열
      let pairArr = [];

      window.onload = function () {
        // 1. 카드를 배열에 등록해요.
        initRandNumArr();

        // 3. 화면에 카드를 8초 보여주고, 카드를 가려요. 카드를 가리면서 게임이 자동으로 시작해요.
        // showAll -> hideAll -> clickAble
        toggleBtnListned(false);
        showAll();

        // 4초 동안 카드를 보여주고 뒤집어버려요.
        setTimeout(() => {
          hideAll();
          // 힌트, 재시작 등의 사용자 버튼의 동작을 허용합니다.
          toggleBtnListned(true);
        }, SHOW_ALL_TIME);
      };

      // 카드를 배열에 초기화 해요.
      let initRandNumArr = () => {
        randNumArr = Array.from(new Array(CARDS_NUM), (e, i) => i).sort((a, b) => Math.random() - 0.5);
      };

      // 모든 카드를 보여준다.(앞면이 보이게 한다.)
      let showAll = () => {
        // 카드가 보여지는 동안은 카드가 활성화(클릭, 이벤트) 되지 않아요.
        toggleCardListener(false);

        // 섞인 숫자 배열을 통해서 카드를 태그로 만들어내요.
        board.innerHTML = randNumArr.reduce((prev, num, index) => {
          // data-index 속성은 카드의 숫자를 알아내기 위한 배열의 인덱스입니다.
          prev += `<img src=./src/${num}.png data-index='${index}' draggable='false'>`;
          return prev;
        }, "");
      };

      // 힌트 버튼이 눌리면 작동해요.
      let hint = () => {
        // 버튼의 동작을 잠시 막아놓아요.
        toggleBtnListned(false);
        // 모든 카드를 보여줍니다.
        showAll();

        // 힌트 시간만큼 후에 카드를 뒤집고 비활성화 되었던 버튼과 카드의 클릭 이벤트를 활성화 합니다.
        setTimeout(() => {
          hideAll();
          toggleBtnListned(true);
          toggleCardListener(true);
        }, SHOW_HINT_TIME);
      };
      // 모든 카드를 덮는다.(뒷면이 보이게 한다.)
      let hideAll = () => {
        const cards = board.children;

        // 이미 맞춘 카드를 제외하고 전부 뒤집어요.
        for (const card of cards) {
          if (pairArr.indexOf(card.getAttribute("data-index")) === -1) {
            flipBack(card);
          }
        }
      };

      // 게임 재시작을 담당하는 메서드에요.
      let reStart = () => {
        // 게임 점수판을 0점으로 초기화합니다.
        setScore(0);

        // 정답 배열을 전부 비워줍니다.
        pairArr = [];

        // 카드를 섞고 카드를 전부 보여줍니다.
        initRandNumArr();

        // 모든 카드를 보여주어요.
        showAll();

        // 4초뒤에 카드를 숨겨요
        setTimeout(hideAll, SHOW_ALL_TIME);
      };

      // 카드를 뒤집어요.
      let flipImg = (e) => {
        // 동일한 카드를 검증하기 위한 배열에는 실제 선택된 카드 객체가 담겨야해요.
        const card = e.target;

        // 선택된 카드의 앞면을 보여주어요.
        flipFront(card);

        // 한장의 카드가 선택되어있는 상황에서 버튼의 작동을 막아요.
        toggleBtnListned(false);

        // 비교를 위한 배열에 카드를 넣어요.
        if (!twoCards.length) {
          twoCards.push(card);
        } else if (twoCards.includes(card)) {
          // 같은 카드가 눌렸어요.
          flipBack(card);
          // 카드 비교를 위한 배열을 비웁니다.
          twoCards.pop();
        } else {
          // 처음과 다른 카드가 눌렸습니다.
          twoCards.push(card);
        }

        // 두장의 카드가 뒤집혀야 다음 단계로 진행할 수 있어요.
        if (!(twoCards.length === 2)) return;

        // 두 카드의 비교가 끝나기 전까지 다른 카드를 선택하지 못합니다.
        toggleCardListener(false);
        // 힌트, 재시작 등의 사용자 버튼의 동작을 잠시 차단합니다.
        toggleBtnListned(false);

        // 두장의 카드에요
        const CARD1 = twoCards.shift();
        const CARD2 = twoCards.shift();

        // 두 카드가 동일한가요?
        if (isSameCards(CARD1, CARD2)) {
          // 두 카드가 동일하면 클릭 이벤트를 제거해요.
          CARD1.classList.remove("clickAble");
          CARD2.classList.remove("clickAble");

          // 정답 배열에 정답인 카드의 data-index값을 저장합니다.
          pairArr.push(CARD1.getAttribute("data-index"));
          pairArr.push(CARD2.getAttribute("data-index"));

          // 스코어를 수정해요.
          setScore(pairArr.length * 100);

          // 게임을 재개해요. 게임 재개시 버튼도 다시 동작합니다.
          setTimeout(() => {
            toggleCardListener(true);
            toggleBtnListned(true);
          }, 300);

          // 모든 카드를 다 맞췄나요?
          if (isAllPair()) {
            // 모든 카드를 맞췄습니다 게임을 종료해요.
            window.alert("축하합니다");
          }
          return;
        }

        // 두 카드가 동일하지 않을때 틀린 카드를 잠시 보여준 후 카드를 뒤집어요
        setTimeout(() => {
          toggleBtnListned(true);
          flipBack(CARD1, CARD2);
        }, 800);
      };

      // 점수판을 수정합니다.
      let setScore = (num) => {
        let scoreBoard = document.getElementById("score");
        if (typeof num === "number") scoreBoard.innerText = `score : ${num}`;
      };

      // 모든 카드의 짝이 맞았는지 검증하는 함수입니다.
      let isAllPair = () => {
        return pairArr.length === CARDS_NUM;
      };

      // 선택 된 카드의 앞면을 보여주는 함수입니다.
      let flipFront = (card) => {
        // 선택된 카드의 진짜 숫자는 해당 카드 이미지 태그의 data-index의 값을 통해 알 수 있어요.
        const realNumber = randNumArr[card.getAttribute("data-index")];

        // 카드가 앞면이 보여질때는 뒤집혀있으면 안되어요.
        flipAnimation(card, false);

        // 카드의 원래 모습을 보여줍니다.
        card.src = `./src/${realNumber}.png`;
      };

      // 카드를 다시 뒷면으로 돌려놓습니다.
      let flipBack = (card1, card2) => {
        // 다시 카드가 뒤집히는 애니메이션을 부여합니다.
        flipAnimation(card1, true);
        if (card2) flipAnimation(card2, true);

        // 이 메서드는 인자가 한개만 호출될 때가 있어서 코드를 작성할때 예외상황을 대비해야 합니다.
        card1.src = `./src/hide.png`;
        if (card2) card2.src = `./src/hide.png`;

        // 카드를 다시 뒤집어 놓은 후에 사용자와의 상호작용을 활성화 합니다.
        toggleCardListener(true);
      };

      // 두 카드가 동일한지를 비교하는 함수입니다.
      let isSameCards = (card1, card2) => {
        // 카드의 data-index 어트리뷰트를 가져와요.
        // 해당 번호로 섞여있는 카드 배열에 접근하면 카드의 진짜 숫자를 알 수 있어요.
        const a = randNumArr[card1.getAttribute("data-index")];
        const b = randNumArr[card2.getAttribute("data-index")];

        // 두 카드의 동일 여부는 카드번호가 26번 떨어져있는가 입니다.
        return a === parseInt((b + 26) % 52);
      };

      // 카드의 클릭 이벤트를 켜고 끌 수 있습니다.
      let toggleCardListener = (flag) => {
        const cards = board.children;

        for (const card of cards) {
          // 카드의 선택 효과를 활성화 / 비활성화 합니다.
          if (flag) {
            // 이미 맞춘 카드들은 이벤트리스너를 주면 안돼요.
            if (pairArr.indexOf(card.getAttribute("data-index")) === -1) {
              // 카드들에 css 선택효과(마우스 호버시)를 부여합니다.
              card.classList.add("clickAble");

              // 카드의 클릭 이벤트를 활성화 합니다.
              card.onclick = flipImg;
            }
          } else {
            card.classList.remove("clickAble");
            card.onclick = null;
          }
        }
      };

      // 선택된 카드에 뒤집히는 효과를 주거나, 빼앗습니다.
      let flipAnimation = (card, flag) => {
        if (flag) card.classList.add("flip");
        else card.classList.remove("flip");
      };

      // 사용자 조작 버튼들을 활성/비활성화 하는 메서드 입니다.
      let toggleBtnListned = (flag) => {
        document.getElementById("restartBtn").onclick = flag ? reStart : null;
        document.getElementById("hintBtn").onclick = flag ? hint : null;
      };
    </script>
  </body>
</html>
